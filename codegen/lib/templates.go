// Copyright (c) 2020 Sam Blenny
// SPDX-License-Identifier: Apache-2.0 OR MIT
//
package lib

import (
	"bytes"
	"strings"
	"text/template"
)

// Render the command line usage message
func RenderUsageTemplate(confirm string, fonts []FontSpec) string {
	context := usageTemplateContext{confirm, fonts}
	return renderTemplate(usageTemplate, "usage", context)
}

// Render rust source code for font file with index functions and static arrays
func RenderFontFileTemplate(f FontSpec, gs GlyphSet, m3Seed uint32) string {
	context := fontFileTemplateContext{f, gs, m3Seed}
	return renderTemplate(fontFileTemplate, "fontfile", context)
}

// Holds data for rendering usageTemplate
type usageTemplateContext struct {
	Confirm string
	Fonts   []FontSpec
}

// Holds data for rendering fontFileTemplate
type fontFileTemplateContext struct {
	Font   FontSpec
	GS     GlyphSet
	M3Seed uint32
}

// Return a string from rendering the given template and context data
func renderTemplate(templateString string, name string, context interface{}) string {
	fmap := template.FuncMap{"ToLower": strings.ToLower}
	t := template.Must(template.New(name).Funcs(fmap).Parse(templateString))
	var buf bytes.Buffer
	err := t.Execute(&buf, context)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

// Template with usage instructions for the command line tool
const usageTemplate = `
This tool generates fonts in the form of rust source code.
To confirm that you want to write the files, use the {{.Confirm}} switch.

Font files that will be generated:{{range $f := .Fonts}}
  {{$f.RustOut}}{{end}}

Usage:
    go run main.go {{.Confirm}}
`

// Template with rust source code for a outer structure of a font file
const fontFileTemplate = `// DO NOT MAKE EDITS HERE because this file is automatically generated.
// To make changes, see blitstr/codegen/main.go
//
// Copyright (c) 2020 Sam Blenny
// SPDX-License-Identifier: Apache-2.0 OR MIT
//
// NOTE: The copyright notice above applies to the rust source code in this
// file, but not to the bitmap graphics encoded in the DATA array (see credits).
//
// CREDITS:
{{.Font.Legal}}
//! {{.Font.Name}} Font
#![forbid(unsafe_code)]
#![allow(dead_code)]

use super::{GlyphData, NoGlyphErr};

/// Maximum height of glyph patterns in this bitmap typeface.
/// This will be true: h + y_offset <= MAX_HEIGHT
pub const MAX_HEIGHT: u8 = {{.Font.Size}};

/// Seed for Murmur3 hashes in the HASH_* index arrays
pub const M3_SEED: u32 = {{.M3Seed}};

/// Return Okay(offset into DATA[]) for start of blit pattern for grapheme cluster.
///
/// Before doing an expensive lookup for the whole cluster, this does a pre-filter
/// check to see whether the first character falls into one of the codepoint ranges
/// for Unicode blocks included in this font.
///
/// Returns: Result<(blit pattern offset into DATA, bytes of cluster used by match)>
pub fn get_blit_pattern_offset(cluster: &str) -> Result<(GlyphData, usize), NoGlyphErr> {
    let first_char: u32;
    match cluster.chars().next() {
        Some(c) => first_char = c as u32,
        None => return Err(NoGlyphErr),
    }
    return match first_char {
        {{ range $_, $k := .GS.IndexKeys -}}
        {{- with $dex := index $.GS.Index $k -}}
        0x{{printf "%X" $k.Low}}..=0x{{printf "%X" $k.High}} => {
            {{ range $_, $gcLen := $dex.ClusterLengthList -}}
            if let Some((offset, bytes_used)) = find_{{ToLower $k.Name}}(cluster, {{$gcLen}}) {
                Ok((GlyphData::{{$.Font.Name}}(offset), bytes_used))
            } else {{ end }}{
                Err(NoGlyphErr)
            }
        }
        {{ end -}}
        {{- end -}}
        _ => Err(super::NoGlyphErr),
    };
}

{{ range $_, $k := .GS.IndexKeys -}}
{{- with $dex := index $.GS.Index $k -}}
/// Use binary search on table of grapheme cluster hashes to find blit pattern for grapheme cluster.
/// Only attempt to match grapheme clusters of length limit codepoints.
fn find_{{ToLower $k.Name}}(cluster: &str, limit: u32) -> Option<(usize, usize)> {
    let (key, bytes_hashed) = super::murmur3(cluster, M3_SEED, limit);
    match HASH_{{$k.Name}}.binary_search(&key) {
        Ok(index) => return Some((OFFSET_{{$k.Name}}[index], bytes_hashed)),
        _ => None,
    }
}

/// Index of murmur3(grapheme cluster); sort matches OFFSET_{{$k.Name}}
const HASH_{{$k.Name}}: [u32; {{len $dex}}] = [
    {{$dex.RustCodeForClusterHashes}}
];

/// Lookup table of blit pattern offsets; sort matches HASH_{{$k.Name}}
const OFFSET_{{$k.Name}}: [usize; {{len $dex}}] = [
    {{$dex.RustCodeForOffsets}}
];

{{ end -}}
{{- end -}}

#[cfg(target_os = "none")]
pub(crate) static DATA_LOCATION: core::sync::atomic::AtomicU32 = core::sync::atomic::AtomicU32::new(0);
pub(crate) const DATA_LEN: usize = {{.GS.DataLen}};

#[cfg(not(target_os = "none"))]
/// Packed glyph pattern data.
/// Record format:
///  [offset+0]: ((w as u8) << 16) | ((h as u8) << 8) | (yOffset as u8)
///  [offset+1..=ceil(w*h/32)]: packed 1-bit pixels; 0=clear, 1=set
/// Pixels are packed in top to bottom, left to right order with MSB of first
/// pixel word containing the top left pixel.
///  w: Width of pattern in pixels
///  h: Height of pattern in pixels
///  yOffset: Vertical offset (pixels downward from top of line) to position
///     glyph pattern properly relative to text baseline
pub const DATA: [u32; {{.GS.DataLen}}] = [
{{.GS.Code}}];

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    // If this fails, there's probably a hash collision, so change the seed.
    fn test_hashes_unique_and_sorted() {
{{- range $_, $k := .GS.IndexKeys }}
        for i in 0..HASH_{{$k.Name}}.len()-1 {
            assert!(HASH_{{$k.Name}}[i] < HASH_{{$k.Name}}[i+1]);
        }{{ end }}
    }
}
`
